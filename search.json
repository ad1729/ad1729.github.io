[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "My professional interests revolve around statistics / machine learning, programming, distributed computing, writing clean code, and using models to make real-world decisions.\nIn my free time, I like to read, cook, cycle, play tennis, and learn languages.\nThe primary reason for starting this (mostly) technical blog is to work through some (technical) concepts or challenges I encounter. Additional reasons include having my R / Python code in a clean and easy-to-navigate format, and to share recipes once in a while. I’ve been talking about wanting to have a blog since 2012, so I’m glad that I finally got around to having one in 2022.\nYou can reach out to me via LinkedIn or via email (first name [dot] last name [at] gmail)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Akshat Dwivedi",
    "section": "",
    "text": "Miscellaneous\n\n\nMeasurement\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nJan 9, 2023\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nAnalysis\n\n\nSimulation\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nAug 16, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMiscellaneous\n\n\n\n\n\n\n\n\n\n\n\nAug 1, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/hello-world/index.html",
    "href": "posts/hello-world/index.html",
    "title": "Hello, World!",
    "section": "",
    "text": "This first post is to check whether the features I want for this blog work as desired.\nThese can be summarized in a non-exhaustive list as:"
  },
  {
    "objectID": "posts/hello-world/index.html#math",
    "href": "posts/hello-world/index.html#math",
    "title": "Hello, World!",
    "section": "Math",
    "text": "Math\nThe OLS estimator is given by the equation \\(\\hat\\beta_\\text{OLS} = (X^\\mathsf{T} X)^{-1} X^\\mathsf{T} y\\).\nOn the other hand, the ridge estimator is given by the following formula\n\\[\\hat\\beta_\\text{ridge} = (X^\\mathsf{T} X + \\lambda I)^{-1} X^\\mathsf{T} y\\]\nwhere \\(\\lambda \\in [0, \\infty)\\) controls the amount of shrinkage applied to the coefficients."
  },
  {
    "objectID": "posts/hello-world/index.html#r-code",
    "href": "posts/hello-world/index.html#r-code",
    "title": "Hello, World!",
    "section": "R code",
    "text": "R code\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\n\np <- iris %>% \n  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) + \n  geom_point() + \n  theme_classic()\n\nvanilla ggplot\n\nplot(p)\n\n\n\n\nplotly plot\n\nplotly::ggplotly(p)"
  },
  {
    "objectID": "posts/how-many-ratings-do-i-need/index.html",
    "href": "posts/how-many-ratings-do-i-need/index.html",
    "title": "How Many Five-Star Ratings Do I Need?",
    "section": "",
    "text": "The screenshot indicates an average1 rating of 4.5 stars out of a total of \\(n = 363\\) reviews, and additionally lists the percent of time a rating between 1-5 was given.1 Unweighted, I assume.\nIt seemed like an easy enough problem – perfect to explore on a rainy, gray Saturday in November – so I decided to have a crack at it.\nAfter doing some trivial algebra, somewhat successfully writing a for-loop, and adequately pleased with the solution, I posted the write-up for my initial approach on RPubs and sent off the answer2 to my friend.2 Spoiler: she needed between 47-50 5-star ratings to pull up the average rating to 4.6. Apologies if you were eagerly waiting for the end to find out what the answer was.\nHowever, while going through this document to clean it up for the blog (in 2022), I realized there’s a simpler way of solving this problem. Before I describe it further, I’m going to load some R packages and extract the data from the image into R objects.\n\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nn <- 363\n\n# percent ratings scaled to [0,1]\np <- c(0.06, 0.01, 0.02, 0.12, 0.79) %>%\n  set_names(nm = 1:5) %>% \n  print()\n\n   1    2    3    4    5 \n0.06 0.01 0.02 0.12 0.79 \n\n\nWhat made me rethink my approach was that I previously ended up with the wrong ratings vector after converting the (rounded) percentages into counts3.3 Although I mostly worked around it afterwards via simulation.\nSo for example, 79% out of 363 ratings were 5-star ratings, which translates to 286.77 and rounded to the nearest integer becomes 287. But this isn’t the only integer that rounds to 79% when divided by 363. Any integer \\(k\\) when divided by 363 that ends up in the (open) interval (78.5%, 79.5%) would be a possible candidate.\n\nseq(284, 289, 1) %>% \n  set_names(nm = ~ .x) %>% \n  map_dbl(.f = ~ round(100 * .x / 363))\n\n284 285 286 287 288 289 \n 78  79  79  79  79  80 \n\n\nSo any one of 285-288 5-star ratings are compatible with the information in the screenshot. We can get the same range for the other ratings (i.e., 1-4).\n\nplausible_counts_per_rating <- p %>% map(.f = function(prop) {\n  approx_val <- round(prop * n)\n  possible_vals <- seq(from = approx_val - 10, to = approx_val + 10, by = 1) %>% \n    set_names(nm = ~ .x) %>% \n    map_dbl(.f = ~ round(.x / n, 2)) %>% \n    keep(.p = ~ .x == prop) %>% \n    names()\n}) %>% \n  as_tibble(.name_repair = ~ paste('x', .x, sep = \"\"))\n\nplausible_counts_per_rating\n\n# A tibble: 4 × 5\n  x1    x2    x3    x4    x5   \n  <chr> <chr> <chr> <chr> <chr>\n1 20    2     6     42    285  \n2 21    3     7     43    286  \n3 22    4     8     44    287  \n4 23    5     9     45    288  \n\n\nEach column shows the plausible values for the number of times a rating was provided. We can create all possible combinations of these values to identify the subset of \\(4 ^ 5 = 1024\\) possible combinations that are compatible with the information in the screenshot, i.e., a mean of 4.5 when rounded to 1 decimal place and a total of 363 ratings.\n\nrating_combinations <- plausible_counts_per_rating %>%\n  # create all combinations of all values in all columns\n  expand(crossing(x1, x2, x3, x4, x5)) %>%\n  mutate(across(.fns = as.integer), \n         total_ratings = x1 + x2 + x3 + x4 + x5, \n         sum_ratings = x1 + (2 * x2) + (3 * x3) + (4 * x4) + (5 * x5), \n         mean_rating = round(sum_ratings / 363, 1)) %>% \n  print(n = 10)\n\n# A tibble: 1,024 × 8\n      x1    x2    x3    x4    x5 total_ratings sum_ratings mean_rating\n   <int> <int> <int> <int> <int>         <int>       <dbl>       <dbl>\n 1    20     2     6    42   285           355        1635         4.5\n 2    20     2     6    42   286           356        1640         4.5\n 3    20     2     6    42   287           357        1645         4.5\n 4    20     2     6    42   288           358        1650         4.5\n 5    20     2     6    43   285           356        1639         4.5\n 6    20     2     6    43   286           357        1644         4.5\n 7    20     2     6    43   287           358        1649         4.5\n 8    20     2     6    43   288           359        1654         4.6\n 9    20     2     6    44   285           357        1643         4.5\n10    20     2     6    44   286           358        1648         4.5\n# … with 1,014 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n\npossible_ratings <- rating_combinations %>% \n  filter(total_ratings == 363, mean_rating == 4.5) %>% \n  print(n = Inf)\n\n# A tibble: 3 × 8\n     x1    x2    x3    x4    x5 total_ratings sum_ratings mean_rating\n  <int> <int> <int> <int> <int>         <int>       <dbl>       <dbl>\n1    23     4     9    42   285           363        1651         4.5\n2    23     5     7    43   285           363        1651         4.5\n3    23     5     8    42   285           363        1650         4.5\n\n\nSo one of these three possible vectors is used to produce the statistics shown in the screenshot.\nThe formula for computing the (arithmetic) mean can be rearranged to easily calculate the required number of five-star ratings to bring the mean from 4.5 to 4.6.\nLet \\(n_1\\) denote the number of additional five-star ratings, \\(y\\) the (weighted) sum of the rating counts, and \\(n\\) the current number of ratings (i.e., 363) in the following equation:\n\\[\\frac{y + (n_1 \\times 5)}{n + n_1} = 4.6\\]\nThis can be rewritten as\n\\[5n_1 = 4.6 \\times (n + n_1) - y\\]\nand simplified to yield\n\\[n_1 = \\frac{(4.6 \\times n) - y}{0.4}\\]\nand coded up as an R function\n\nnum_five_star <- function(sum_ratings, total_ratings) {\n  ((4.6 * total_ratings) - sum_ratings) / 0.4\n}\n\nApplying this function to the possible ratings vector leads to\n\npossible_ratings %>% \n  mutate(extra_5_stars = ceiling(num_five_star(sum_ratings, total_ratings))) %>% \n  select(-total_ratings, -mean_rating)\n\n# A tibble: 3 × 7\n     x1    x2    x3    x4    x5 sum_ratings extra_5_stars\n  <int> <int> <int> <int> <int>       <dbl>         <dbl>\n1    23     4     9    42   285        1651            47\n2    23     5     7    43   285        1651            47\n3    23     5     8    42   285        1650            50\n\n\nso 47-50 additional 5-star ratings are needed to pull up the average4 to 4.6, assuming that the future ratings are all five-star ratings.4 exact average, not an average resulting from rounding 4.57 (say) to 4.6. In the latter case, fewer than 47 five-star ratings would be required."
  },
  {
    "objectID": "posts/jigger-volume-estimation/index.html",
    "href": "posts/jigger-volume-estimation/index.html",
    "title": "Determining the volume of my (cocktail) jigger",
    "section": "",
    "text": "In the fall of 2022, I was gifted a cocktail mixing set for my birthday1 which included a cocktail jigger. A jigger is an essential tool for mixing cocktails as it makes it relatively easy to measure the quantity of drinks that go into a cocktail (e.g., 40 ml of vodka, 10 ml of sugar syrup, etc.).1 It was put to use immediately and some delicious whiskey sours were made.\nAfter a couple of months of not having to use my cocktail set due to travelling, I couldn’t remember the volume of either side (i.e., basin) of the jigger, nor could I find the remains of the packaging material for reference. Googling showed that jiggers come in different sizes, so I decided to measure the volume myself."
  },
  {
    "objectID": "posts/jigger-volume-estimation/index.html#method-1-weight-based",
    "href": "posts/jigger-volume-estimation/index.html#method-1-weight-based",
    "title": "Determining the volume of my (cocktail) jigger",
    "section": "Method 1: Weight-based",
    "text": "Method 1: Weight-based\nThe digital kitchen scale I own has this nifty feature where it can account for and automatically subtract the weight of the container so that only the weight of the object of interest is shown.\nThe scale measures weight in grams (g), but I was interested in the volume in milliliters (ml). Quick Googling reminded me of the nifty fact I learned and forgot a long time ago, that the weight of 1 g of water is approximately equal to the volume occupied by 1 ml of water.\nPlacing the jigger on the scale and ensuring that the scale read zero g, I filled up the larger basin to the top with tap water. The scale showed 51g, which was odd as I was expecting it to show a number that would be a multiple of five (i.e., a number ending with a 0 or a 5)3.3 although some jigger images online show possible measurements like 22.5 ml (which is 0.75 oz)\nSo obviously4 the next logical step was to take multiple measurements. After making sure to drain the jigger, clean the scale of any spilled water droplets, and ensuring the scale read zero, I took the next measurement which read 48 g. Excellent. I love consistent results.4 obvious to a Statistician or a Data Scientist\nSo I took another 8 measurements, and repeated this process for the smaller basin of the jigger as well. These measurements are visualized below.\nEach time I filled it to what I perceived to be the top but I got different measurements. I don’t think that this variability is necessarily due to the variability of the digital scale itself but most likely due to the variability in my perception of what counts as ‘filled to the brim’.\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\n\nvol_big <- c(51, 48, 48, 52, 49, 50, 51, 52, 50, 50)\nvol_small <- c(31, 28, 32, 30, 30, 29, 32, 32, 31, 31)\n\ntibble(\n  Basin = c(rep(\"Smaller basin\", 10), rep(\"Larger basin\", 10)),\n  `Volume (in ml)` = c(vol_small, vol_big)\n) %>%\n  mutate(Basin = forcats::fct_rev(Basin)) %>% \n  ggplot(aes(x = `Volume (in ml)`, fill = Basin, color = Basin)) +\n  geom_dotplot(binwidth = 1, stroke = 2, dotsize = 0.7) +\n  theme_classic() +\n  theme(legend.position = \"none\", \n        axis.title.x = element_text(size = 16), \n        axis.text.x = element_text(size = 16), \n        strip.text = element_text(size = 16)) + \n  scale_y_continuous(NULL, breaks = NULL) + \n  scale_fill_manual(values = c(\"#E69F00\", \"darkgreen\")) + \n  scale_color_manual(values = c(\"#E69F00\", \"darkgreen\")) + \n  facet_wrap(~ Basin, scales = 'free')\n\n\n\n\n\nAveraging these measurements gave me a volume of 50.1 ml for the big basin and 30.6 ml for the smaller basin.\nInterestingly5, it also indicates6 that I usually put anywhere between 48-52 (or 28-32) ml of a drink when I’m supposed to add 50 (or 30) ml.5 to me and literally nobody else6 assuming the digital scale is not causing this variability"
  },
  {
    "objectID": "posts/jigger-volume-estimation/index.html#method-2-dimension-based",
    "href": "posts/jigger-volume-estimation/index.html#method-2-dimension-based",
    "title": "Determining the volume of my (cocktail) jigger",
    "section": "Method 2: Dimension-based",
    "text": "Method 2: Dimension-based\nThe shape of a jigger reminded me of a (partial) cone, so I measured7 the height \\(h\\) from the mouth of each basin to the point where it joins the other basin, and the diameter \\(2R\\) of the mouth of each basin.7 using a pair of digital calipers I totally had lying around the house and did not use this exercise as an excuse to buy\nFor the smaller basin, the height \\(h_s\\) was measured as 3.48 cm, and a diameter of 3.9 cm (so a radius \\(R_s\\) of 1.95 cm).\nFor the larger basin, the height \\(h_l\\) was measured as 5.28 cm, and a diameter of 4.18 cm (so a radius \\(R_l\\) of 2.09 cm).\nThe radius \\(r\\) of the base where the two basins are attached to each other is \\(2.78 / 2 = 1.39\\).\nPlugging these into the formula for a partial cone88 here’s a derivation (and another) of the volume of a cone using calculus, which I’ve probably derived in school or university and long since forgotten\n\\[V = \\frac{1}{3} \\times \\pi \\times h \\times \\Big(R^2 + Rr + r^2\\Big)\\]\n\n\nCode\ncone <- function(h, r, R) {\n  (pi * h * (R^2 + (R * r) + r^2)) / 3\n}\n\n\ngave a volume9 of 30.8 ml for the smaller basin and 50.9 for the larger basin which was very similar to the numbers from the other method, but not exactly equal to 30 and 50 ml due to (human) measurement error.9 using the conversion factor of 1 cm3 to 1 ml for volume of water\nA few days after doing all these measurements, I came across a similar (in spirit?) post on a blog I frequent, which inspired me to write this up."
  }
]