{
  "hash": "ff789245a4394ce7785ddf646463ef1e",
  "result": {
    "markdown": "---\ntitle: Setup and test Python by programming a word blossom solver\ndate: '2023-10-08'\ncategories:\n  - Python\ncode-fold: false\nreference-location: margin\nimage: image.png\n---\n\nAll the previous posts on this blog have been in R. But sometimes I want to program in another language -- Python, Scala, etc. So in the process of setting up and testing Python with Quarto, I decided to write this test post where I implement a set of simple functions to solve the *word blossom*[^1] game given a set of letters along with some constraints (min / max / total word length, etc).\n\n[^1]: Twenty years of being familiar with this game and I never knew what it was called until I looked it up for this post.\n\nBefore proceeding, let's load some packages.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# for generating list of letters\nimport string \nimport random\n\n# for plotting\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import RegularPolygon\nimport numpy as np\n\n# for loading the word list\nimport json\n\n# for typing, because why not\nfrom typing import List\n```\n:::\n\n\nThe variants I've encountered online -- [this](https://blossomwordgame.com/), or [this](https://www.merriam-webster.com/games/blossom-word-game) -- consist of a sequence of 6 letters arranged around a central letter.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef generate_letters(seed: int, nchar: int = 7) -> List[str]:\n    random.seed(seed)\n\n    central_letter = random.choice([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    alphabet = string.ascii_uppercase.replace(central_letter, \"\")\n    non_central_letters = random.sample(population=alphabet, k=nchar-1)\n\n    return [central_letter] + non_central_letters\n\nletters = generate_letters(seed=95)\n\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['U', 'Q', 'Y', 'R', 'E', 'P', 'A']\n```\n:::\n:::\n\n\nVisually, it looks something like this (using a modified version of code from [this stackexchange post](https://stackoverflow.com/questions/46525981/how-to-plot-x-y-z-coordinates-in-the-shape-of-a-hexagonal-grid))[^2]\n\n[^2]: Not having written any Python for more than a year, I'd forgotten how much *fun* it was to customize `matplotlib` plots.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\ndef plot_word_blossom(letters: List[str]) -> None:\n  coord = [[0,0,0],[0,1,-1],[-1,1,0],[-1,0,1],[0,-1,1],[1,-1,0],[1,0,-1]]\n  colors = [[\"orange\"]] + [[\"white\"]] * 6\n  labels = [[l] for l in letters]\n  \n  # Horizontal cartesian coords\n  hcoord = [c[0] for c in coord]\n  \n  # Vertical cartersian coords\n  vcoord = [2. * np.sin(np.radians(60)) * (c[1] - c[2]) /3. for c in coord]\n  \n  fig, ax = plt.subplots(1)\n  ax.set_aspect(\"equal\")\n  \n  # Add some coloured hexagons\n  for x, y, c, l in zip(hcoord, vcoord, colors, labels):\n      color = c[0]\n      hex = RegularPolygon((x, y), numVertices=6, radius=2. / 3., \n                           orientation=np.radians(30), \n                           facecolor=color, alpha=1, edgecolor='k')\n      ax.add_patch(hex)\n      # Also add a text label\n      ax.text(x, y, l[0], ha=\"center\", va=\"center\", size=20)\n  \n  # Also add scatter points in hexagon centres\n  # setting alpha = 0 to not show the points\n  ax.scatter(hcoord, vcoord, c=[c[0].lower() for c in colors], alpha=0)\n  \n  plt.axis(\"off\")\n  plt.show();\n\nplot_word_blossom(letters)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=375 height=389}\n:::\n:::\n\n\nThe goal is to make as many words as possible that meet the following conditions\n\n-   each word must be an actual word (say present in a British English dictionary)\n\n-   word length between 4-7\n\n-   each word must contain the central letter\n\nThe version I used to play as a kid had the additional constraint that each letter could be used only once.\n\nTo solve this, I load a dictionary (obtained from [here](https://github.com/dwyl/english-words/tree/master)) and just look up words that match the requirements.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef get_list_of_eligible_words(min_length: int = 4, \n                               max_length: int = 7, \n                               no_duplicates: bool = True) -> List[str]:\n      with open(\"words_dictionary.json\") as f:\n            words_dict = json.load(f)\n\n      words = list(words_dict.keys())\n      n_all = len(words)\n\n      if no_duplicates:\n            # keep words with no duplicate characters, \n            # e.g., set turns 'coop' into {'c', 'o', 'p'}\n            words = [w for w in words if len(w) == len(set(w))]\n\n      words = [w for w in words if len(w) >= min_length and len(w) <= max_length]\n\n      print(f\"Found {len(words):,} words out of {n_all:,} that meet the criteria.\")\n      \n      return words\n      \nwords = get_list_of_eligible_words()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound 43,239 words out of 370,101 that meet the criteria.\n```\n:::\n:::\n\n\nThis next function takes the list of dictionary words and filters the subset of words that match the criteria.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef get_words(words: List[str], letters: List[str]) -> List[str]:\n    central_letter = letters[0].lower()\n    letters_set = set([l.lower() for l in letters])\n    result = sorted([word for word in words if set(word.lower()).issubset(letters_set) and central_letter in word.lower()])\n    print(f\"Found {len(result)} words for the given letters {letters!r} with {central_letter!r} as the central letter.\")\n    return result\n\nprint(get_words(words=words, letters=letters), sep=\",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound 21 words for the given letters ['U', 'Q', 'Y', 'R', 'E', 'P', 'A'] with 'u' as the central letter.\n['aperu', 'paque', 'pareu', 'perau', 'peru', 'prau', 'prue', 'pure', 'purey', 'puya', 'quae', 'quar', 'quare', 'quay', 'query', 'quey', 'rupa', 'urea', 'yaru', 'yaup', 'yauper']\n```\n:::\n:::\n\n\nHmm, some of these words are pretty uncommon. For example, 'paque' -- [pronounced 'pack'](https://www.thefreedictionary.com/Paque) -- means Easter (similar to the French word 'PÃ¢ques'). 'Perau' is an alternate spelling for 'perahu' which [means boat and comes from](https://en.wiktionary.org/wiki/perahu) Indonesian / Malay. These are both new to me.\n\nI was tempted to add a little self-contained *Shiny* application within this quarto document using [shinylive](https://shiny.posit.co/py/docs/shinylive.html) ([github link](https://github.com/quarto-ext/shinylive)) which I discovered while writing this post. However, I decided against this for the moment since the shinylive examples hosted on github-pages took a noticeable amount of time to load on my fast laptop + browser + internet connection.\n\nTrying to use both RStudio and VS Code, qmd and ipynb files together seems a bit clunky at the moment. I guess with time I'll end up finding workarounds to reduce friction in this workflow.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}