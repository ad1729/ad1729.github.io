{
  "hash": "22d765ee622467b3b72d8e688401b8ea",
  "result": {
    "markdown": "---\ntitle: \"How Many Five-Star Ratings Do I Need?\"\ndate: \"2022-08-16\"\ncategories: [Analysis, Simulation, R]\ntoc: false\ncode-fold: false\nreference-location: margin\n---\n\n\nIn the fall of 2021, a friend who runs her own business sent me this picture with the accompanying question:\n\n![](5-star-rating.jpg)\n\nThe screenshot indicates an average[^1] rating of 4.5 stars out of a total of $n = 363$ reviews, and additionally lists the percent of time a rating between 1-5 was given.\n\n[^1]: Unweighted, I assume.\n\nIt seemed like an easy enough problem -- perfect to explore on a rainy, gray Saturday in November -- so I decided to have a crack at it.\n\nAfter doing some trivial algebra, somewhat successfully writing a for-loop, and adequately pleased with the solution, I posted the write-up for my initial approach on [RPubs](https://rpubs.com/akshatdwivedi/five-star-ratings) and sent off the answer[^2] to my friend.\n\n[^2]: Spoiler: she needed between 47-50 5-star ratings to pull up the average rating to 4.6. Apologies if you were eagerly waiting for the end to find out what the answer was.\n\nHowever, while going through this document to clean it up for the blog (in 2022), I realized there's a simpler way of solving this problem. Before I describe it further, I'm going to load some R packages and extract the data from the image into R objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nn <- 363\n\n# percent ratings scaled to [0,1]\np <- c(0.06, 0.01, 0.02, 0.12, 0.79) %>%\n  set_names(nm = 1:5) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   1    2    3    4    5 \n0.06 0.01 0.02 0.12 0.79 \n```\n:::\n:::\n\n\nWhat made me rethink my approach was that I previously ended up with the wrong ratings vector after converting the (rounded) percentages into counts[^3].\n\n[^3]: Although I mostly worked around it afterwards via simulation.\n\nSo for example, 79% out of 363 ratings were 5-star ratings, which translates to 286.77 and rounded to the nearest integer becomes 287. But this isn't the only integer that rounds to 79% when divided by 363. Any integer $k$ when divided by 363 that ends up in the (open) interval (78.5%, 79.5%) would be a possible candidate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(284, 289, 1) %>% \n  set_names(nm = ~ .x) %>% \n  map_dbl(.f = ~ round(100 * .x / 363))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n284 285 286 287 288 289 \n 78  79  79  79  79  80 \n```\n:::\n:::\n\n\nSo any one of 285-288 5-star ratings are compatible with the information in the screenshot. We can get the same range for the other ratings (i.e., 1-4).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplausible_counts_per_rating <- p %>% map(.f = function(prop) {\n  approx_val <- round(prop * n)\n  possible_vals <- seq(from = approx_val - 10, to = approx_val + 10, by = 1) %>% \n    set_names(nm = ~ .x) %>% \n    map_dbl(.f = ~ round(.x / n, 2)) %>% \n    keep(.p = ~ .x == prop) %>% \n    names()\n}) %>% \n  as_tibble(.name_repair = ~ paste('x', .x, sep = \"\"))\n\nplausible_counts_per_rating\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  x1    x2    x3    x4    x5   \n  <chr> <chr> <chr> <chr> <chr>\n1 20    2     6     42    285  \n2 21    3     7     43    286  \n3 22    4     8     44    287  \n4 23    5     9     45    288  \n```\n:::\n:::\n\n\nEach column shows the plausible values for the number of times a rating was provided. We can create all possible combinations of these values to identify the subset of $4 ^ 5 = 1024$ possible combinations that are compatible with the information in the screenshot, i.e., a mean of 4.5 when rounded to 1 decimal place and a total of 363 ratings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrating_combinations <- plausible_counts_per_rating %>%\n  # create all combinations of all values in all columns\n  expand(crossing(x1, x2, x3, x4, x5)) %>%\n  mutate(across(.fns = as.integer), \n         total_ratings = x1 + x2 + x3 + x4 + x5, \n         sum_ratings = x1 + (2 * x2) + (3 * x3) + (4 * x4) + (5 * x5), \n         mean_rating = round(sum_ratings / 363, 1)) %>% \n  print(n = 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(.fns = as.integer)`.\nCaused by warning:\n! Using `across()` without supplying `.cols` was deprecated in dplyr 1.1.0.\nℹ Please supply `.cols` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,024 × 8\n      x1    x2    x3    x4    x5 total_ratings sum_ratings mean_rating\n   <int> <int> <int> <int> <int>         <int>       <dbl>       <dbl>\n 1    20     2     6    42   285           355        1635         4.5\n 2    20     2     6    42   286           356        1640         4.5\n 3    20     2     6    42   287           357        1645         4.5\n 4    20     2     6    42   288           358        1650         4.5\n 5    20     2     6    43   285           356        1639         4.5\n 6    20     2     6    43   286           357        1644         4.5\n 7    20     2     6    43   287           358        1649         4.5\n 8    20     2     6    43   288           359        1654         4.6\n 9    20     2     6    44   285           357        1643         4.5\n10    20     2     6    44   286           358        1648         4.5\n# ℹ 1,014 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npossible_ratings <- rating_combinations %>% \n  filter(total_ratings == 363, mean_rating == 4.5) %>% \n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 8\n     x1    x2    x3    x4    x5 total_ratings sum_ratings mean_rating\n  <int> <int> <int> <int> <int>         <int>       <dbl>       <dbl>\n1    23     4     9    42   285           363        1651         4.5\n2    23     5     7    43   285           363        1651         4.5\n3    23     5     8    42   285           363        1650         4.5\n```\n:::\n:::\n\n\nSo one of these three possible vectors is used to produce the statistics shown in the screenshot.\n\nThe formula for computing the (arithmetic) mean can be rearranged to easily calculate the required number of five-star ratings to bring the mean from 4.5 to 4.6.\n\nLet $n_1$ denote the number of additional five-star ratings, $y$ the (weighted) sum of the rating counts, and $n$ the current number of ratings (i.e., 363) in the following equation:\n\n$$\\frac{y + (n_1 \\times 5)}{n + n_1} = 4.6$$\n\nThis can be rewritten as\n\n$$5n_1 = 4.6 \\times (n + n_1) - y$$\n\nand simplified to yield\n\n$$n_1 = \\frac{(4.6 \\times n) - y}{0.4}$$\n\nand coded up as an R function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_five_star <- function(sum_ratings, total_ratings) {\n  ((4.6 * total_ratings) - sum_ratings) / 0.4\n}\n```\n:::\n\n\nApplying this function to the possible ratings vector leads to\n\n\n::: {.cell}\n\n```{.r .cell-code}\npossible_ratings %>% \n  mutate(extra_5_stars = ceiling(num_five_star(sum_ratings, total_ratings))) %>% \n  select(-total_ratings, -mean_rating)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 7\n     x1    x2    x3    x4    x5 sum_ratings extra_5_stars\n  <int> <int> <int> <int> <int>       <dbl>         <dbl>\n1    23     4     9    42   285        1651            47\n2    23     5     7    43   285        1651            47\n3    23     5     8    42   285        1650            50\n```\n:::\n:::\n\n\nso 47-50 additional 5-star ratings are needed to pull up the average[^4] to 4.6, assuming that the future ratings are all five-star ratings.\n\n[^4]: exact average, not an average resulting from rounding 4.57 (say) to 4.6. In the latter case, fewer than 47 five-star ratings would be required.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}